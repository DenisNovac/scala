# Неявные преобразования

Неявные преобразования типа `S` к типу `T` задаются неявным значением функционального типа `S=>T`, или неявным методом, который способен преобразовывать к значению требуемого типа.

Оно используется в двух случаях:

- Если выражение `e` типа `S` не подходит под ожидаемый тип выражения `T`;
- Если мы выбираем член `e.m`, где `e` является представителем типа `S`, при этом выбранное имя `m` не найдено среди доступных селекторов, принадлежащих типу `S`.

В первом случае выполняется поиск приведения `c`, которое можно применить к `e`, чтобы тип результата стал соответствовать ожидаемому `T`. Во втором случае выполняется поиск преобразования `c`, которое применимо к `e` и результат которого бы содержал член с именем `m`.

Если неявный метод `List[A] => Ordered[List[A]]` находится в области видимости также, как и неявный метод `Int => Ordered[Int]`, то следующая операция с двумя списками типа `List[Int]` является допустимой:

```scala
List(1,2,3) <= List(4,5)

```

Неявный метод `Int => Ordered[Int]` предоставляется автоматически через `scala.Predef.intWrapper`. Ниже приведен пример объявления неявного метода `List[A] => Ordered[List[A]]`.

```scala
implicit def list2ordered[A](x:List[A])
                            (implicit elem2ordered: A => Ordered[A]): Ordered[List[A]] =
                          new Ordered[List[A]] {
                            // заменить на более полезную реализацию
                            override def compare(that: List[A]): Int = 1
                          }

```
