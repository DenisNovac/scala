/**
 * Можно объявлять отдельные объекты. Ведут они себя так же как написанные
 * на Java реализации шаблона Одиночка.
 *
 * Объявление метода:
 * def имя(вход): выход = {}
 *
 *
 *
 */

import scala.language.postfixOps

object FunctionalProgramming {
  val any: Any = 1

  def main(args: Array[String]): Unit = {
    val test: Int = 1
    println("Hello, " + "!")

    // [String] - параметризация типа. В Java это были < >
    val test_array = new Array[Int](2)
    // А для массива используются () вместо []
    test_array(0) = 0
    test_array(1) = 1

    // использование оператора . и скобок на конце - необязательно:
    println(("Hello"+" "+"!").toUpperCase())
    println("Hello".toUpperCase)

    // но для использования нужно явно сделать импорт scala.language.postfixOps
    // Здесь пробел заменяет оператор . , что позволяет очистить код от засоряющих скобок
    println("Hello " + "world" toUpperCase)

    // быстрое создание массива
    val fast_array = 1 to 3
    for (i <- 0 to fast_array.length)
      println(i)

    println()

    /**
     * Каждая функция в Scala - экземпляр класса Function, у которого есть
     * метод apply
     */
    def addOne(a: Int) = a+1
    // знак подчёркивания ставится на место аргумента функции
    /**
     * Вообще, знак подчёркивания имеет огромное количество применений, но здесь он применяется
     * как замена для параметров в функциях
     */
    val functionValue = addOne _
    println(functionValue.apply(1))
    // apply подразумевается по умолчанию, поэтому можно использовать собки:
    println(functionValue(1))

    /**
     * В ООП всё - объект, и функция - тоже.
     * apply призван закрыть пробелы между ООП и функциональщиной в Scala.
     *
     * Он используется для вызова функции, но математически это называется "Применить
     * (apply) функцию к аргументам"
     *
     * Написание .apply() каждый раз при вызове функции - ООП-путь, а Scala позволяет
     * опустить это и вызывать функции по (), как если бы мы были в функциональном
     * языке.
     *
     * Получается, что каждая функция может быть использована как объект (метод apply), но и
     * каждый объект - может быть использован как функция (замена apply на () ).
     *
     * Есть много случаев, когда мы хотим использовать объект как функцию. Например, паттерн
     * Factory.
     */

    // анонимные функции (лямбда-функции)
    val f = (x: Int) => x + 1
    print(f(2))

  }



  // сумма чисел в диапазоне
  def sum(a: Int, b: Int): Int = {
    var result = 0
    for (i <- a to b) result += i
    result
  }





}
