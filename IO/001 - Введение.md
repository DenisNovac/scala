# Монада IO

Если чистые функции не могут иметь I/O, как функциональное приложение может делать что-то в принципе? Вывод зависит только от ввода - так как хоть что-то сделать, если в процессе работы нельзя читать никакие вводы и нельзя писать никакие выводы?

Как быть? Нарушить правило "писать только чистые функции".

Главное идея - написать как можно больше логики в функциональном стиле, а затем уже обрабатывать все виды I/O. Получается, все I/O (а это могут быть файлы, графический интерфейс, работа с БД и веб-сервером) будут более-менее похожи на работу кода на Java. Затем эти I/O нужно "обернуть" в функциональные обёртки.

Предположим, у нас есть функция

```scala
def promptUserForUsername: String = ???
```

Явно она должна давать пользователю что-то вводить. Мы не видим, как она это делает, но понимаем по названию.

Каждый пользователь должен иметь уникальное имя. Поэтому, в любой момент когда эта функция вызывается, она будет иметь разный результат. Мы увидели:

- Функция получает инпут от юзера;
- Функция возвращает разный результат в каждый вызов.

Таким образом, это не "чистая" функция (*impure*).

Но теперь представим, что та же функция возвращает строку, обёрнутую в некоторый класс:

```scala
def promptUserForUsername: IP[String] = ???
```

Выглядит примерно как Option/Some/None паттерн Скалы. Что же она даёт?

Главный плюс - она сразу же показывает, что является *impure* функцией. 

*“The IO monad does not make a function pure. It just makes it obvious that it’s impure.”* - Martin Odersky in Google Groups Scala debate

## Делает ли она функцию pure?

Она делает из значений:

```scala
"alvin"
"kim"
"xena"
```

Значения:

```scala
IO("alvin")
IO("kim")
IO("xena")
```


## Откуда взялись I/O?

I/O появились в Haskell и являлись тем, как Haskell работает с input/output-операциями.

